<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzle de Código de Isla</title>
    <!-- Incluye Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Paleta de colores: Tonos suaves de azul, blanco, gris y acentos vibrantes */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f9ff; /* Azul muy claro */
            color: #334155; /* Azul grisáceo oscuro */
            display: flex;
            flex-direction: column; /* Para apilar secciones verticalmente */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
        }

        /* Estilos para el nuevo título principal de la página */
        .main-page-title {
            font-size: 3.5rem; /* text-5xl para ser muy grande */
            font-weight: 900; /* font-black para el máximo peso */
            color: #1d4ed8; /* Azul intenso */
            text-align: center;
            margin-bottom: 2.5rem; /* Más espacio debajo del título */
            text-shadow: 2px 2px 5px rgba(0,0,0,0.15);
            line-height: 1.2; /* Interlineado ajustado */
        }
        /* Ajuste responsivo para el título principal en móviles */
        @media (max-width: 768px) {
            .main-page-title {
                font-size: 2.5rem; /* Más pequeño para móviles */
                margin-bottom: 1.5rem;
            }
        }


        /* Estilos para la sección de instrucciones */
        #puzzle-instructions-section {
            background-color: #e3f2fd; /* Azul claro suave */
            padding: 2rem 1rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.08);
            margin-bottom: 2rem;
            width: 100%;
            max-width: 700px; /* Ancho máximo para la sección de instrucciones */
        }
        .instruction-title {
            font-size: 2.25rem; /* text-3xl */
            font-weight: 800; /* font-extrabold */
            color: #007bff; /* Azul vibrante */
            text-align: center;
            margin-bottom: 1.5rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }
        .instruction-card-puzzle {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border-radius: 1rem;
            padding: 1.25rem;
            box-shadow: 0 5px 10px rgba(0,0,0,0.08);
            margin-bottom: 1rem; /* Espacio entre tarjetas */
            text-align: left;
            border: 1px solid #cceeff; /* Borde sutil */
        }
        .instruction-card-puzzle:last-child {
            margin-bottom: 0;
        }
        .instruction-card-puzzle h3 {
            font-size: 1.5rem; /* text-xl */
            font-weight: 700; /* font-bold */
            color: #1d4ed8; /* Azul intenso */
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .instruction-card-puzzle p {
            font-size: 1rem; /* text-base */
            color: #475569; /* Gris azulado */
            line-height: 1.6; /* Mantener la legibilidad en instrucciones */
        }
        .instruction-icon-puzzle {
            font-size: 2rem; /* Tamaño del emoji */
            line-height: 1; /* Asegura que el emoji no tenga espacio extra */
        }

        /* Contenedor principal del juego de puzle */
        #puzzle-game-container {
            max-width: 600px;
            width: 100%;
            background-color: #ffffff;
            padding: 2.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1), 0 0 50px rgba(147, 197, 253, 0.5); /* Sombra suave con brillo azul */
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 1.5rem;
        }

        /* Título del juego */
        .game-title {
            font-size: 2.75rem; /* text-4xl */
            font-weight: 800; /* font-extrabold */
            color: #1d4ed8; /* Azul intenso */
            text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
        }
        /* Ajuste para el título del juego en móviles */
        @media (max-width: 768px) {
            .game-title {
                font-size: 1.75rem; /* Más pequeño para móviles */
                line-height: 1.2; /* Espaciado sencillo */
            }
        }


        /* Contenedor del tablero de puzle */
        #puzzle-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Cuadrícula 3x3 */
            grid-template-rows: repeat(3, 1fr);
            width: 450px; /* Ancho fijo para el tablero en desktop */
            height: 450px; /* Altura fija para el tablero en desktop */
            background-color: #e2e8f0; /* Gris claro */
            border-radius: 0.75rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2); /* Sombra interna para profundidad */
            overflow: hidden; /* Asegura que las imágenes no se salgan */
            border: 4px solid #93c5fd; /* Borde azul claro */
            position: relative; /* Para posicionar las piezas absolutas */
        }
        /* Ajuste responsivo para el tablero */
        @media (max-width: 640px) {
            #puzzle-board {
                width: 100%; /* Ocupa todo el ancho disponible */
                height: auto; /* Altura automática para mantener proporción */
                padding-top: 100%; /* truco para mantener un aspecto cuadrado (height = width) */
            }
        }

        /* Estilo de las piezas del puzle */
        .puzzle-tile {
            background-size: 450px 450px; /* Tamaño total de la imagen original en desktop */
            border: 2px solid #a78bfa; /* Borde morado para separar piezas */
            cursor: pointer;
            transition: transform 0.2s ease-out, left 0.2s ease-out, top 0.2s ease-out; /* Transición para el movimiento suave */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem; /* Para números en desarrollo, no visible con imagen */
            font-weight: bold;
            color: rgba(255, 255, 255, 0.8);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
            position: absolute; /* Posicionamiento absoluto dentro del #puzzle-board */
            box-sizing: border-box; /* Asegura que padding/border no afecten el tamaño total */
        }
        @media (max-width: 640px) {
            .puzzle-tile {
                /* El width y height serán calculados por JS para mantener la proporción 1/3 */
            }
        }

        .puzzle-tile:hover {
            transform: scale(1.02);
            z-index: 10; /* Para que se vea encima al hacer hover */
        }

        .puzzle-tile.selected {
            border: 4px solid #FFD700; /* Borde amarillo brillante para la pieza seleccionada */
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            z-index: 100; /* Asegura que la pieza seleccionada esté encima */
        }
        /* Nueva clase para el número en la esquina inferior derecha */
        .tile-code {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background-color: rgba(0, 0, 0, 0.6); /* Fondo semi-transparente oscuro */
            color: white;
            font-size: 0.9rem; /* Tamaño de fuente del código */
            padding: 2px 5px;
            border-radius: 4px;
            font-weight: bold;
            z-index: 10; /* Asegura que el código esté sobre la imagen */
        }


        /* Controles y estado */
        #controls {
            display: flex;
            flex-wrap: wrap; /* Permite que los botones se envuelvan en pantallas pequeñas */
            justify-content: center;
            align-items: center; /* Alinea verticalmente si hay texto encima */
            gap: 1rem;
            margin-top: 1rem;
            width: 100%;
            flex-direction: column; /* Apila el texto y el botón */
        }

        .control-button {
            flex-grow: 1; /* Permite que los botones crezcan para llenar el espacio */
            min-width: 120px; /* Ancho mínimo para cada botón */
            padding: 0.75rem 1.5rem; /* Ajustar padding */
            border-radius: 9999px; /* rounded-full */
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            color: white; /* Texto blanco para todos los botones de control */
            border: none;
        }
        /* Estilo específico para el botón de solución con color esmeralda */
        .control-button.solve-button-custom {
            background-color: #10b981; /* Esmeralda-500 */
        }
        .control-button.solve-button-custom:hover {
            background-color: #059669; /* Esmeralda-600 */
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
        }
        .control-button.solve-button-custom:active {
            transform: translateY(1px);
        }

        /* Se oculta por defecto la barra de estado */
        #status-bar {
            display: none; /* Oculta el elemento */
            flex-wrap: wrap; /* Envuelve en pantallas pequeñas */
            justify-content: space-between;
            width: 100%;
            font-size: 1.125rem; /* text-lg */
            font-weight: 500;
            padding-top: 0.5rem;
            border-top: 1px solid #e2e8f0;
            gap: 0.5rem; /* Espacio entre elementos en wrap */
        }
        /* Esto es por si en algún momento se decide mostrarlo con JS */
        #status-bar.show-status {
            display: flex;
        }
        #status-bar p {
            flex-grow: 1;
            text-align: center;
            line-height: 1.2; /* Espaciado sencillo */
        }
        @media (min-width: 640px) {
            #status-bar p {
                text-align: left; /* Alineación a la izquierda para desktop */
                flex-grow: 0; /* No crece para mantener el espacio justo */
            }
        }


        /* Mensaje de retroalimentación */
        #message-box {
            font-size: 1.5rem; /* text-2xl */
            font-weight: 700; /* font-bold */
            color: #10b981; /* Esmeralda-500 */
            margin-top: 0.5rem; 
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            text-align: center;
            width: 100%;
            line-height: 1.2; /* Interlineado sencillo, ya estaba configurado */
        }
        #message-box.show {
            opacity: 1;
        }

        /* --- Estilos de la Ventana Modal (Común para todas las modales) --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Fondo semi-transparente oscuro */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Asegura que esté por encima de todo */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: white;
            padding: 1.5rem; /* Default padding for desktop */
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 0 0 20px rgba(100, 150, 250, 0.5);
            position: relative;
            max-width: 600px; /* Reduced max-width for PC for a more contained look */
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto; /* Default for desktop, can be overridden by media query */
        }

        .modal-content img {
            max-width: 100%;
            max-height: 70vh; /* Máximo 70% de la altura de la vista para la imagen en desktop */
            height: auto;
            border-radius: 0.5rem;
            object-fit: contain; /* Asegura que la imagen se ajuste sin recortar */
            margin-bottom: 1rem;
        }
        /* Estilo para el contenedor de códigos en la modal de vista previa */
        #modal-codes-display {
            font-size: 1.25rem; /* Aumentado para codes */
            font-weight: bold;
            color: #334155;
            background-color: #f0f4f8;
            padding: 0.75rem;
            border-radius: 0.5rem;
            width: 100%;
            text-align: center;
            word-wrap: break-word; /* Permite que los códigos largos se ajusten */
            line-height: 1.2; /* Espaciado sencillo */
        }
        /* Nuevo estilo para mensaje dentro de la modal de feedback/error */
        #modal-feedback-message {
            font-size: 1.1rem; /* Más pequeña que los códigos */
            font-weight: 600;
            color: #dc2626; /* red-600 */
            margin-top: 1rem; /* Margen superior para separarlo de la imagen */
            margin-bottom: 1rem; /* Margen inferior para separarlo de los códigos */
            line-height: 1.2; /* Espaciado sencillo */
            text-align: center; /* Centrar el texto */
        }
        
        /* Modal Title adjustments */
        #modal-title {
            font-size: 2rem; /* Default for desktop */
            text-align: center;
        }

        /* Responsive adjustments for mobile view */
        @media (max-width: 768px) { /* Tablet breakpoint for mobile adjustments */
            .modal-content {
                max-width: 95%; /* Wider on small screens */
                max-height: 90vh; /* Ajustar para que quepa todo sin scroll */
                padding: 1rem; /* Smaller padding on mobile */
                overflow-y: hidden; /* Prevent scrolling */
                justify-content: space-between; /* Distribute space vertically */
            }
            .modal-content img {
                max-height: 60vh; /* Aumento la altura máxima de la imagen para que ocupe más espacio */
                margin-bottom: 0.5rem; /* Less margin */
            }
            #modal-title {
                font-size: 1.5rem; /* Smaller title on mobile */
                line-height: 1.2; /* Espaciado sencillo */
            }
            #modal-feedback-message {
                font-size: 0.9rem; /* Más pequeño que los códigos en móvil */
                margin-top: 0.5rem;
                margin-bottom: 0.5rem;
                line-height: 1.2; /* Espaciado sencillo */
            }
            #modal-codes-display {
                font-size: 1.0rem; /* Más grande que el feedback, pero ajustado para móvil */
                padding: 0.5rem;
                line-height: 1.2; /* Espaciado sencillo */
            }
        }


        .modal-close-button {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            font-size: 2rem;
            color: red; /* Color rojo para la 'X' */
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease;
        }
        .modal-close-button:hover {
            background-color: #e2e8f0; /* Gray-200 */
        }

        /* --- Estilos para Confeti --- */
        #confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Permite clics a través del confeti */
            z-index: 2000; /* Asegura que esté por encima de todo */
            overflow: hidden; /* Evita barras de desplazamiento */
        }

        @keyframes fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 0;
            }
            20% {
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .confetti-piece {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--confetti-color);
            border-radius: 50%; /* Piezas de confeti redondas */
            animation: fall 3s ease-out forwards;
            animation-delay: var(--delay);
            opacity: 0;
        }

        /* --- Estilos para la Modal de Recompensa (Formulario) --- */
        #reward-modal-content {
            text-align: left; /* Alinea el texto del formulario a la izquierda */
            width: 100%; /* Ocupa el 100% del ancho del modal-content padre */
        }
        #reward-modal-content label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #475569;
            font-size: 1rem;
        }
        /* Se aplica a input[type="text"], input[type="email"] y select */
        #reward-modal-content input[type="text"],
        #reward-modal-content input[type="email"],
        #reward-modal-content select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-size: 1rem;
            color: #334155;
            background-color: #f8fafc; /* Fondo claro para los inputs */
        }
        #reward-modal-content input[type="text"]:focus,
        #reward-modal-content input[type="email"]:focus,
        #reward-modal-content select:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.25);
            outline: none;
        }
        #reward-modal-content .info-display {
            background-color: #e0f2fe; /* Azul muy claro para info */
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            font-size: 0.95rem;
            color: #1e3a8a; /* Azul oscuro */
            font-weight: 500;
        }
        /* Eliminamos los estilos del texto de seguridad porque se eliminó el elemento */
        /*
        #reward-modal-content .security-text {
            font-size: 0.85rem;
            color: #64748b;
            margin-top: 1.5rem;
            line-height: 1.4;
            padding-top: 1rem;
            border-top: 1px dashed #e2e8f0;
        }
        */
        #reward-modal-content .send-button {
            background-color: #22c55e; /* Verde esmeralda */
            color: white;
            padding: 0.85rem 2rem;
            border-radius: 9999px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
            width: 100%; /* Ocupa todo el ancho */
            margin-top: 0.5rem; /* CAMBIO: Reduce el margen superior para acercar al texto */
        }
        #reward-modal-content .send-button:hover {
            background-color: #16a34a; /* Verde más oscuro */
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
        }
        #reward-modal-content .send-button:active {
            transform: translateY(1px);
        }

    </style>
</head>
<body>
    <!-- Nuevo título grande al inicio de la página -->
    <h1 class="main-page-title">🔓 Desbloquea tu Recurso 🔑</h1>

    <!-- Sección de Instrucciones del Puzle -->
    <section id="puzzle-instructions-section">
        <!-- Título de la sección de instrucciones simplificado -->
        <h2 class="instruction-title">🎯 MISIÓN:</h2>
        <div class="instruction-card-puzzle">
            <!-- Texto de la misión ajustado a text-2xl y centrado -->
            <p class="text-2xl font-semibold text-gray-900 mb-2 text-center">Tu misión es armar la imagen y completar un código secreto, para ser enviado.</p>
        </div>
        <div class="instruction-card-puzzle">
            <h3 class="text-2xl font-semibold text-gray-900 mb-2 instruction-icon-puzzle">👆 Paso 1:</h3>
            <p class="text-gray-700">Haz clic en la pieza que contenga el código correcto para ordenar las piezas. Debes colocar las piezas en orden, de izquierda a derecha y de arriba hacia abajo.</p>
        </div>
        <div class="instruction-card-puzzle">
            <h3 class="text-2xl font-semibold text-gray-900 mb-2 instruction-icon-puzzle">💡 Paso 2:</h3>
            <p class="text-gray-700">Usa el botón "Ver Solución" para tener una vista previa a la imagen completa y el orden de los códigos.</p>
        </div>
        <div class="instruction-card-puzzle">
            <h3 class="text-2xl font-semibold text-gray-900 mb-2 instruction-icon-puzzle">✅ Paso 3:</h3>
            <p class="text-gray-700">Envía el código generado para acceder a tu recurso exclusivo.</p>
        </div>
    </section>

    <!-- Contenedor principal del mini-juego de puzle -->
    <div id="puzzle-game-container">
        <!-- Título del juego -->
        <h1 class="game-title">Resuelve el Puzle</h1>

        <div id="puzzle-board">
            <!-- Las piezas del puzle se generarán con JavaScript -->
        </div>

        <div id="controls">
            <!-- Botón "Ver Solución" con el nuevo color verde esmeralda -->
            <button id="solve-button" class="control-button solve-button-custom">Ver Solución</button>
        </div>

        <!-- Se oculta por defecto la barra de estado con `display: none;` en el CSS -->
        <div id="status-bar">
            <p>Movimientos: <span id="moves-count">0</span></p>
            <p>Tiempo: <span id="time-elapsed">00:00</span></p>
        </div>

        <p id="message-box"></p>
    </div>

    <!-- Ventana Modal de Vista Previa de Imagen y Mensajes -->
    <div id="preview-modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-button" class="modal-close-button">&times;</button>
            <!-- El título de la modal se gestiona dinámicamente en JS -->
            <h3 id="modal-title" class="text-2xl font-bold mb-4"></h3> 
            <!-- La imagen siempre va primero -->
            <img id="modal-preview-image" src="" alt="Vista previa de la imagen del puzle">
            <!-- Luego el mensaje de feedback/error -->
            <p id="modal-feedback-message" class="text-lg text-red-600 font-semibold mb-4"></p>
            <!-- Y finalmente los códigos -->
            <div id="modal-codes-display" class="mt-4">
                <!-- Aquí se mostrarán los códigos de las piezas -->
            </div>
        </div>
    </div>

    <!-- Nueva Ventana Modal de Recompensa (Formulario) -->
    <div id="reward-modal-overlay" class="modal-overlay">
        <div class="modal-content" id="reward-modal-content">
            <button id="reward-modal-close-button" class="modal-close-button">&times;</button>
            <!-- CAMBIO: Título del formulario actualizado -->
            <h3 class="text-2xl font-bold mb-4 text-center">Resumen de Datos</h3>
            
            <div class="info-display">
                <p><strong>Código del Puzle:</strong> <span id="form-puzzle-code"></span></p>
                <p><strong>Movimientos:</strong> <span id="form-moves-count"></span></p>
                <p><strong>Tiempo Total:</strong> <span id="form-time-elapsed"></span></p>
                <p><strong>Imagen del Puzle:</strong> <a id="form-image-url" href="#" target="_blank" class="text-blue-600 hover:underline">Ver Imagen</a></p>
            </div>

            <!-- Mensaje encima del botón -->
            <p class="text-lg italic text-center mb-1">Enviar datos y solicitar acceso al recurso</p>

            <!-- CAMBIO: Nombre del botón y link de Telegram -->
            <button id="send-resource-button" class="send-button">
                Telegram
            </button>
        </div>
    </div>

    <!-- Contenedor para el confeti -->
    <div id="confetti-container"></div>

    <script>
        const puzzleBoard = document.getElementById('puzzle-board');
        const solveButton = document.getElementById('solve-button');
        const movesCountDisplay = document.getElementById('moves-count');
        const timeElapsedDisplay = document.getElementById('time-elapsed');
        const messageBox = document.getElementById('message-box');

        // Modal elements (Preview & Error)
        const previewModalOverlay = document.getElementById('preview-modal-overlay');
        const modalCloseButton = document.getElementById('modal-close-button');
        const modalTitle = document.getElementById('modal-title'); 
        const modalFeedbackMessage = document.getElementById('modal-feedback-message'); 
        const modalPreviewImage = document.getElementById('modal-preview-image');
        const modalCodesDisplay = document.getElementById('modal-codes-display'); 

        // Reward Modal elements (Form)
        const rewardModalOverlay = document.getElementById('reward-modal-overlay');
        const rewardModalCloseButton = document.getElementById('reward-modal-close-button');
        const formPuzzleCode = document.getElementById('form-puzzle-code');
        const formMovesCount = document.getElementById('form-moves-count');
        const formTimeElapsed = document.getElementById('form-time-elapsed');
        const formImageUrl = document.getElementById('form-image-url');
        const sendResourceButton = document.getElementById('send-resource-button');

        // Confetti elements
        const confettiContainer = document.getElementById('confetti-container');

        // Configuración del puzle
        const IMAGE_URL = "https://blog.centraldereservas.com/wp-content/uploads/2017/06/Isla-Gran-Cayman.jpg"; // URL de la imagen del puzle
        const GRID_SIZE = 3; // Tamaño del puzle (GRID_SIZE x GRID_SIZE)
        const TILE_COUNT = GRID_SIZE * GRID_SIZE; // Número total de piezas

        // Variables de estado del juego
        let tiles = []; 
        let moves = 0;
        let timerInterval;
        let startTime;
        let gameStarted = false; 
        let gamePausedByModal = false; 
        let elapsedTimeAtPause = 0; 
        let nextCorrectIndexToSolve = 0; 
        
        let isPuzzlePermanentlyCompleted = false;

        // Colores para el confeti
        const CONFETTI_COLORS = [
            '#FFC0CB', '#FFD700', '#ADFF2F', '#87CEEB', '#FF6347', '#BA55D3', '#00FA9A', '#FF4500', '#42A5F5', '#FF80AB'
        ];

        /**
         * Genera un array de códigos alfanuméricos únicos.
         * @param {number} count - Cantidad de códigos a generar.
         * @param {number} length - Longitud de cada código.
         * @returns {string[]} Un array de códigos únicos.
         */
        function generateUniqueRandomCodes(count, length) {
            const characters = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const codes = new Set();
            while (codes.size < count) {
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += characters.charAt(Math.floor(Math.random() * characters.length));
                }
                codes.add(result);
            }
            return Array.from(codes);
        }

        /**
         * Inicializa el puzle creando y posicionando las piezas.
         * Resetea el estado del juego.
         */
        function initializePuzzle() {
            puzzleBoard.innerHTML = ''; 
            tiles = [];
            moves = 0;
            movesCountDisplay.textContent = moves;
            timeElapsedDisplay.textContent = '00:00';
            hideMessage(); 
            stopTimer(); 
            gameStarted = false; 
            gamePausedByModal = false; 
            elapsedTimeAtPause = 0; 
            nextCorrectIndexToSolve = 0; 
            rewardModalOverlay.classList.remove('show'); 

            if (localStorage.getItem('puzzleCompleted') === 'true') {
                isPuzzlePermanentlyCompleted = true;
                displayPermanentCompletionMessage(); 
                return; 
            } else {
                isPuzzlePermanentlyCompleted = false;
                puzzleBoard.style.pointerEvents = 'auto'; 
                solveButton.classList.remove('hidden'); 
            }

            const tileCodes = generateUniqueRandomCodes(TILE_COUNT, 3); 

            const boardSize = puzzleBoard.offsetWidth; 
            const tileSize = boardSize / GRID_SIZE;

            const initialOrderedTiles = [];
            for (let i = 0; i < TILE_COUNT; i++) {
                const tile = document.createElement('div');
                tile.classList.add('puzzle-tile');
                tile.dataset.originalIndex = i; 
                tile.dataset.code = tileCodes[i]; 

                const col = i % GRID_SIZE;
                const row = Math.floor(i / GRID_SIZE);
                
                tile.style.backgroundImage = `url('${IMAGE_URL}')`;
                tile.style.backgroundPosition = `-${col * tileSize}px -${row * tileSize}px`;
                
                tile.style.width = `${tileSize}px`;
                tile.style.height = `${tileSize}px`;

                const codeSpan = document.createElement('span');
                codeSpan.classList.add('tile-code');
                codeSpan.textContent = tile.dataset.code;
                tile.appendChild(codeSpan);

                tile.addEventListener('click', () => handleTileClick(tile));
                initialOrderedTiles.push(tile); 
            }

            tiles = [...initialOrderedTiles]; 
            shuffleTiles(true); 

            tiles.forEach(tile => puzzleBoard.appendChild(tile));

            checkAndAdvanceSolvedTiles();
        }

        /**
         * Muestra un mensaje permanente de que el puzle ya ha sido completado
         * y deshabilita el tablero de juego.
         */
        function displayPermanentCompletionMessage() {
            puzzleBoard.style.pointerEvents = 'none'; 
            solveButton.classList.add('hidden'); 
            
            messageBox.innerHTML = "¡Este puzle ha sido completado! Ya has solicitado tu recurso. ¡Gracias por jugar!";
            messageBox.classList.remove('hidden', 'text-red-600', 'text-blue-600'); 
            messageBox.classList.add('show', 'text-green-600'); 
        }

        /**
         * Mezcla las piezas del puzle visualmente y lógicamente.
         * @param {boolean} isInitialShuffle - True si es la mezcla inicial al cargar/reiniciar.
         */
        function shuffleTiles(isInitialShuffle = false) {
            if (isPuzzlePermanentlyCompleted && !isInitialShuffle) return; 

            for (let i = tiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tiles[i], tiles[j]] = [tiles[j], tiles[i]]; 
            }

            const boardSize = puzzleBoard.offsetWidth;
            const tileSize = boardSize / GRID_SIZE;

            tiles.forEach((tile, currentPos) => {
                const col = currentPos % GRID_SIZE;
                const row = Math.floor(currentPos / GRID_SIZE);

                tile.style.left = `${col * tileSize}px`;
                tile.style.top = `${row * tileSize}px`;
            });
            
            if (!isInitialShuffle) { 
                moves = 0;
                movesCountDisplay.textContent = moves;
                stopTimer();
                timeElapsedDisplay.textContent = '00:00';
                gameStarted = false;
                hideMessage(); 
                elapsedTimeAtPause = 0;
                nextCorrectIndexToSolve = 0; 
                puzzleBoard.style.pointerEvents = 'auto'; 
                solveButton.classList.remove('hidden'); 
                checkAndAdvanceSolvedTiles(); 
            }
        }

        /**
         * Verifica si las primeras piezas ya están en su lugar y avanza `nextCorrectIndexToSolve`
         * sin contar movimientos.
         */
        function checkAndAdvanceSolvedTiles() {
            let advanced = false;
            while (nextCorrectIndexToSolve < TILE_COUNT) {
                const tileInTargetSpot = tiles.find(tile => tiles.indexOf(tile) === nextCorrectIndexToSolve);
                
                if (tileInTargetSpot && parseInt(tileInTargetSpot.dataset.originalIndex) === nextCorrectIndexToSolve) {
                    nextCorrectIndexToSolve++;
                    advanced = true;
                } else {
                    break;
                }
            }
            if (advanced && checkWin()) {
                endGame(); 
            }
        }

        /**
         * Maneja el clic en una pieza para realizar el intercambio inteligente.
         * Se ha modificado para aplicar el orden de resolución.
         * @param {HTMLElement} clickedTile - La pieza HTML clicada.
         */
        function handleTileClick(clickedTile) {
            if (gamePausedByModal || isPuzzlePermanentlyCompleted) return; 

            const clickedTileCurrentIndex = tiles.indexOf(clickedTile);
            const clickedTileOriginalIndex = parseInt(clickedTile.dataset.originalIndex);

            if (clickedTileOriginalIndex !== nextCorrectIndexToSolve) {
                const errorMessagePart1 = `¡Movimiento Incorrecto!`;
                const errorMessagePart2 = `Debes seleccionar la pieza con el código correcto para la posición ${nextCorrectIndexToSolve + 1}.`;
                showModal('error', `${errorMessagePart1}<br>${errorMessagePart2}`); 
                return;
            }

            if (clickedTileCurrentIndex === nextCorrectIndexToSolve) {
                nextCorrectIndexToSolve++; 
                hideMessage(); 
                checkAndAdvanceSolvedTiles(); 
                if (checkWin()) { 
                    endGame();
                }
                return; 
            }

            if (!gameStarted) { 
                startGameTimer();
                gameStarted = true;
            }

            const tileAtTargetPosition = tiles.find(tile => tiles.indexOf(tile) === nextCorrectIndexToSolve);

            [tiles[clickedTileCurrentIndex], tiles[nextCorrectIndexToSolve]] = 
            [tiles[nextCorrectIndexToSolve], tiles[clickedTileCurrentIndex]];

            const boardSize = puzzleBoard.offsetWidth;
            const tileSize = boardSize / GRID_SIZE;

            const clickedTileNewCol = nextCorrectIndexToSolve % GRID_SIZE;
            const clickedTileNewRow = Math.floor(nextCorrectIndexToSolve / GRID_SIZE);
            
            const tileAtTargetPositionNewCol = clickedTileCurrentIndex % GRID_SIZE;
            const tileAtTargetPositionNewRow = Math.floor(clickedTileCurrentIndex / GRID_SIZE);
            
            clickedTile.style.left = `${clickedTileNewCol * tileSize}px`;
            clickedTile.style.top = `${clickedTileNewRow * tileSize}px`;

            tileAtTargetPosition.style.left = `${tileAtTargetPositionNewCol * tileSize}px`;
            tileAtTargetPosition.style.top = `${tileAtTargetPositionNewRow * tileSize}px`;

            moves++; 
            movesCountDisplay.textContent = moves;
            hideMessage(); 
            
            nextCorrectIndexToSolve++;
            checkAndAdvanceSolvedTiles();

            if (checkWin()) {
                endGame();
            }
        }

        /**
         * Verifica si el puzle está completamente resuelto.
         * @returns {boolean} True si el puzle está resuelto, false en caso contrario.
         */
        function checkWin() {
            return nextCorrectIndexToSolve === TILE_COUNT;
        }

        /**
         * Finaliza el juego, detiene el temporizador y activa el confeti.
         * Luego, muestra directamente el formulario de recompensa.
         */
        function endGame() {
            stopTimer(); 
            gameStarted = false; 
            puzzleBoard.style.pointerEvents = 'none'; 
            solveButton.classList.add('hidden'); 

            startConfetti(); 
            
            showMessage("Felicidades, <br>¡Has Completado el Puzle! 🎉", 'success');

            // Reducir el tiempo a 3 segundos antes de mostrar el formulario
            setTimeout(() => {
                messageBox.classList.remove('show'); 
                messageBox.innerHTML = ''; 
                showRewardModal();
            }, 3000); 
        }

        /**
         * Muestra la ventana modal de vista previa o de error.
         * @param {string} type - 'hint' para ver la solución, 'error' para mensaje de movimiento incorrecto.
         * @param {string} [errorMessage=''] - Mensaje específico si el tipo es 'error'.
         */
        function showModal(type, errorMessage = '') {
            if (gameStarted) {
                stopTimer(); 
                gamePausedByModal = true;
            }
            
            const orderedCodesForDisplay = Array.from(puzzleBoard.children) 
                .sort((a, b) => parseInt(a.dataset.originalIndex) - parseInt(b.dataset.originalIndex)) 
                .map(tile => tile.dataset.code) 
                .join('-'); 
            modalCodesDisplay.textContent = orderedCodesForDisplay; 
            
            if (type === 'hint') {
                modalTitle.textContent = "Vista Previa"; 
                modalFeedbackMessage.innerHTML = ""; 
                modalFeedbackMessage.classList.remove('text-red-600');
                modalPreviewImage.src = IMAGE_URL;
                modalPreviewImage.classList.remove('hidden'); 
            } else if (type === 'error') {
                modalTitle.textContent = ""; 
                modalFeedbackMessage.innerHTML = errorMessage; 
                modalFeedbackMessage.classList.add('text-red-600');
                modalPreviewImage.src = IMAGE_URL; 
                modalPreviewImage.classList.remove('hidden'); 
            }
            
            previewModalOverlay.classList.add('show');
        }

        /**
         * Cierra la ventana modal de vista previa y reanuda el juego si estaba pausado.
         */
        function closePreviewModal() {
            previewModalOverlay.classList.remove('show');
            if (gameStarted && gamePausedByModal) {
                startGameTimer(); 
                gamePausedByModal = false;
            }
        }

        /**
         * Muestra la ventana modal del formulario de recompensa, pre-llenando los datos del puzle.
         */
        function showRewardModal() {
            const finalPuzzleCodeOrder = Array.from(puzzleBoard.children)
                .sort((a, b) => parseInt(a.dataset.originalIndex) - parseInt(b.dataset.originalIndex))
                .map(tile => tile.dataset.code)
                .join('-');

            formPuzzleCode.textContent = finalPuzzleCodeOrder;
            formMovesCount.textContent = moves;
            formTimeElapsed.textContent = timeElapsedDisplay.textContent;
            formImageUrl.href = IMAGE_URL; 

            rewardModalOverlay.classList.add('show');
        }

        /**
         * Cierra la ventana modal del formulario de recompensa.
         */
        function closeRewardModal() {
            rewardModalOverlay.classList.remove('show');
        }

        /**
         * Prepara y abre el enlace directo de Telegram para enviar la solicitud de recurso.
         */
        function sendRewardForm() {
            const puzzleCode = formPuzzleCode.textContent;
            const movesMade = formMovesCount.textContent;
            const timeTaken = formTimeElapsed.textContent;
            const imageUrl = IMAGE_URL; 

            // Cuerpo del mensaje que se pre-llenará
            const messageBody = `¡Hola!\n\n` +
                                `He completado el Puzle de Código de Isla con los siguientes resultados:\n\n` +
                                `Código del Puzle Resuelto: ${puzzleCode}\n` +
                                `Movimientos: ${movesMade}\n` +
                                `Tiempo Total: ${timeTaken}\n` +
                                `URL de la Imagen del Puzle: ${imageUrl}\n\n` +
                                `¡Espero mi recurso!\n\n` +
                                `Saludos.`;

            // Link directo a Telegram
            const telegramDirectLink = `https://t.me/delmasbell`;
            const encodedMessage = encodeURIComponent(messageBody);

            window.open(telegramDirectLink + `?text=${encodedMessage}`, '_blank'); 

            localStorage.setItem('puzzleCompleted', 'true');
            displayPermanentCompletionMessage();

            closeRewardModal(); 
        }

        // --- Funciones del temporizador ---
        /**
         * Inicia o reanuda el temporizador del juego.
         */
        function startGameTimer() {
            startTime = Date.now() - (elapsedTimeAtPause * 1000 || 0); 
            timerInterval = setInterval(updateTimer, 1000);
        }

        /**
         * Detiene el temporador del juego y guarda el tiempo transcurrido.
         */
        function stopTimer() {
            clearInterval(timerInterval);
            if (gameStarted) { 
                elapsedTimeAtPause = Math.floor((Date.now() - startTime) / 1000);
            }
        }

        /**
         * Actualiza el tiempo transcurrido en el display cada segundo.
         */
        function updateTimer() {
            const currentElapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(currentElapsedTime / 60);
            const seconds = currentElapsedTime % 60;
            timeElapsedDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // --- Funciones de mensajes (feedback) ---
        /**
         * Muestra un mensaje temporal en la interfaz del juego.
         * @param {string} msg - El mensaje a mostrar.
         * @param {string} type - Tipo de mensaje ('success', 'error', 'info') para aplicar estilos.
         */
        function showMessage(msg, type = 'info') {
            if (messageBox && !isPuzzlePermanentlyCompleted) { 
                messageBox.innerHTML = msg; 
                messageBox.classList.remove('hidden', 'text-green-600', 'text-red-600', 'text-blue-600');
                if (type === 'success') {
                    messageBox.classList.add('text-green-600');
                } else if (type === 'error') {
                    messageBox.classList.add('text-red-600');
                } else if (type === 'info') {
                    messageBox.classList.add('text-blue-600'); 
                }
                messageBox.classList.add('show');
            }
        }

        /**
         * Oculta el mensaje actual en la interfaz del juego.
         */
        function hideMessage() {
            if (!isPuzzlePermanentlyCompleted) {
                messageBox.classList.remove('show'); 
                messageBox.innerHTML = '';
            }
        }

        // --- Funciones de Confeti ---
        /**
         * Inicia una animación de lluvia de confeti.
         */
        function startConfetti() {
            confettiContainer.innerHTML = ''; 

            for (let i = 0; i < 100; i++) { 
                const confettiPiece = document.createElement('div');
                confettiPiece.classList.add('confetti-piece');
                confettiPiece.style.left = `${Math.random() * 100}vw`; 
                confettiPiece.style.top = `${Math.random() * -20}vh`; 
                confettiPiece.style.setProperty('--confetti-color', CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)]);
                confettiPiece.style.setProperty('--delay', `${Math.random() * 2}s`); 
                confettiContainer.appendChild(confettiPiece);
            }

            setTimeout(() => {
                confettiContainer.innerHTML = '';
            }, 3500); 
        }

        // --- Event Listeners ---
        solveButton.addEventListener('click', () => {
            if (!isPuzzlePermanentlyCompleted) {
                showModal('hint'); 
            }
        });

        modalCloseButton.addEventListener('click', closePreviewModal);
        previewModalOverlay.addEventListener('click', (event) => {
            if (event.target === previewModalOverlay) {
                closePreviewModal();
            }
        });
        
        rewardModalCloseButton.addEventListener('click', closeRewardModal);
        sendResourceButton.addEventListener('click', sendRewardForm);

        rewardModalOverlay.addEventListener('click', (event) => {
            if (event.target === rewardModalOverlay) {
                // Se mantiene el comportamiento de no cerrar al hacer clic fuera
            }
        });

        /**
         * Ajusta la posición y tamaño de las piezas del puzle en respuesta a cambios de tamaño de la ventana.
         */
        function adjustTilePositions() {
            const boardSize = puzzleBoard.offsetWidth;
            const tileSize = boardSize / GRID_SIZE;

            tiles.forEach((tile, i) => {
                const col = i % GRID_SIZE; 
                const row = Math.floor(i / GRID_SIZE);

                tile.style.width = `${tileSize}px`;
                tile.style.height = `${tileSize}px`;
                tile.style.left = `${col * tileSize}px`;
                tile.style.top = `${row * tileSize}px`;
                
                tile.style.backgroundSize = `${boardSize}px ${boardSize}px`;
                const originalIndex = parseInt(tile.dataset.originalIndex); 
                const originalCol = originalIndex % GRID_SIZE;
                const originalRow = Math.floor(originalIndex / GRID_SIZE);
                tile.style.backgroundPosition = `-${originalCol * tileSize}px -${originalRow * tileSize}px`;
            });
        }

        // Carga inicial y listeners de redimensionamiento
        window.addEventListener('load', () => {
            initializePuzzle();
            setTimeout(adjustTilePositions, 100); 
        });
        window.addEventListener('resize', () => {
            adjustTilePositions(); 
        });
    </script>
</body>
</html>
